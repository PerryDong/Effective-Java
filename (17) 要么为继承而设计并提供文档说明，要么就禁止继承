一个专门为了继承而设计并且具有良好文档说明的类，意味着：
1） 该类的文档必须精确地描述了改写每一个方法所带来的影响。该类必须有文档说明其可改写的方法的自用性：对于每一个公有的或受保
护的方法或者构造函数，它的文档必须指明它调用了哪些可改写的方法是以什么顺序调用，每个调用的结果是如何影响后续的处理过程的。
惯例是如果一个方法调用了可改写的方法，那么在它的文档注释的末尾应该包含关于这些调用的描述信息。

2） 为了使程序员能够编写出更加有效的子类，而无需承受不必要的痛苦，一个类必须通过某种形式提供适当的钩子(hook)，以便能够进入
到它的内部工作流程中，这样的形式可以是精心选择的受保护方法，也可以是受保护的域，后者少见。

3） 构造函数一定不能调用可被覆盖的方法，无论是直接还是间接进行，因为超类的构造函数在子类的构造函数之前运行。

4） 在一个为了继承而设计的类中，实现Cloneable或Serializable接口，因为clone和readObject方法在行为上非常类似于构造函数，所以
	无论clone还是readObject都不能调用一个可改写的方法，无论是直接还是间接的方式。　　
	对于readObject方法，子类中改写版本的方法将在子类的状态被反序列化之前先被运行；对于clone方法，改写版本的方法将在子类
	的clone方法有机会修正被克隆对象的状态之前先被运行。
	
5） 在一个为了继承而设计的类中实现Serializable接口，且该类有一个readResolve或writeReplace方法，则你必须使readResolve或者
	writeReplace成为受保护的方法，而不是私有的方法。
	
为了继承而设计一个类，要求对这个类有一些实质性的限制。对于那些并非为了安全地进行子类化而设计和编写文档的类（如普通的具体类），
禁止子类化。有两种办法可以禁止子类化：

1） 把类声明为final。
2） 把所有的构造函数变成私有的或包级私有的，增加一些公有的静态工厂来替代构造函数的位置。

如果必须从这样的类来继承，则要确保这类永远不会调用到它的任何可覆盖的方法。