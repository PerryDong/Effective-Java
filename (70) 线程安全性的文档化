如果你没有在一个类的文档中描述其行为的并发情况，使用这个类的程序员将不得不做出某些假设。如果这些假设是错误的，这样得到的程序就可能缺少足够的同步，
或者过度同步。无论属于哪种情况，都可能会发生严重的错误。
一个类为了可被多个线程安全使用，必须在文档中清楚地说明它所支持的线程安全性级别。线程安全性的几种级别：
  1）不可变的——这个类的实例是不可变的。所以不需要同步，这样的例子包括String，Long，BigInteger。
  2）无条件的线程安全——这个类的实例是可变的，但是这个类有足够的内部同步，所以它的实例可以被并发使用，无需任何外部同步。
    例子包括Random，ConconcurrentHashMap。
  3）有条件的线程安全——除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件安全相同。
    例子包括：Collections.synhronized包装返回的集合，它们的迭代器要求外部同步。
  4）非线程安全——这个类的实例是可变的。为了并发使用它们，客户必须利用自己选择的外部同步包围每个方法调用。这样的例子包括通用的集合实现，例如ArrayList
  5) 线程对立的——这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外围同步包围。
上述几种情况也可以概括为：不可变(Immutable)、线程安全(ThreadSafe)、线程不安全(NotThreadSafe)三种情况。

有条件的线程安全类，必须指明哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁。
私有锁只能用在无条件的线程安全类上。私有锁对象模式特别适用于那些专门为继承而设计的类。如果这种类适用它的实例作为锁的对象，
子类可能很容易在无意中妨碍基类的操作，反之亦然。
private final Object lock = new Object(); 
public void foo() {
    synchronized(lock) {
        ……
    }
}

规则：
每个类都应该利用严谨的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。synchronized修饰符与这个文档毫无关系。有条件的线程安全类和无条件的
线程安全类应该按照上述规范编写实现文档。这样可以防止客户端程序和子类的不同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。
