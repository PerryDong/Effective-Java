一般的单例类，如果添加了implements Serializable之后，它就不再是一个单例，因为反序列化可以看做是另一个构造器，此时你就需要使用readResolve()方法。
对于正在被序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化之后，新建的对象上的readResolve方法就会被调用。然后
该方法返回的对象引用将被返回，取代新建的对象。
private Object readResolve() {
	return INSTANCE;
}
该方法忽略了被序列化的对象，只返回该类初始化时创建的那个特殊的实例。因此，实例的序列化形式并不需要包含任何实际的数据；所有的实例域都应该被声明
为transient的。事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient的。

readResolve的可访问性（accessibility）很重要。如果把readResolve方法放在一个final类上，它就应该是私有的。如果把readResolver方法放在一个非final的
类上，就必须认真考虑它的可访问性。如果它是私有的，就不适用于任何子类。如果它是包级私有的，就只适用于同一个包中的子类。如果它是受保护的或者公有的，就适
用于所有没有覆盖它的子类。如果readResolve方法是受保护的或者公有的，并且子类没有覆盖它，对序列化过的子类实例进行反序列化，就会产生一个超类实例，这样有
可能导致ClassCastException异常。

规则：
应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个readResolve方法，并确保该类的
所有实例域都为基本类型，或者是transient的。
