-------------------------------------------------------------------------------------------------------------------------
一般情况下，对于类而言，我们获取一个类的实例时，最常用的方法是提供一个公有的构造器。但是还有一种方法，类可以提供一个公有
的静态工厂方法，它只是个返回类的实例的静态方法而已。但是静态工厂方法却又许多妙用之处。
静态工厂方法与构造器相比的优势
	1） 它们有名称。客户端调用的时候见名知意，而且易于阅读；
	2） 不必每次调用它们的时候都创建一个新对象。尤其是在单实例类中使用非常广泛；
	3） 可以返回原返回类型的任何子类型对象。这个主要根据传入工厂静态方法的参数来实现，只要是已声名的返回类型的子类型；
	4） 创建参数化类型实例的时候，使得代码更加简洁。
		Map<String, List<String>> m = new HashMap<String, List<String>>();  
		使用静态工厂方法后，情况就不一样了：
		public static <K, V>HashMap<K, V> newInstance( ) {  
			return new HashMap<K, V>();  
		} 
		Map<String, List<String>> m = HashMap.newInstance();  
缺点：
	1） 类如果不含公有的或者受保护的构造器，就不能被子类化。
	2） 它们与其他的静态公有方法实际上没有任何区别。
	
下面是静态工厂方法的一些惯用名称：
	valueOf 该方法返回的实例与参数具有相同的值，实际是类型转换方法。
	of  valueOf的一种替代，EnumSet。
	getInstance 返回的实例是通过方法的参数来描述的。对于Singleton单例模式，返回唯一的实例。
	newInstance 返回的实例是一个新的实例，与之前返回的都不相同。
	getType 与getInstance一样，但是在工厂方法处于不同的类时候使用。
	newType 与getInstance一样，但是在工厂方法处于不同的类时候使用。
	
规则：
静态工厂方法和公有构造器各有优缺点，我们应该充分认识它们。但是静态工厂方法通常更合适一些，千万不要在创建对象时
第一反应就是提供公有的构造器。